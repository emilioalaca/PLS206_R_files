{
    "contents" : "library(faraway)\ndata(meatspec) # load meat spectrum data\nmodel1 <- lm(fat ~ ., meatspec[1:172,]) # Model with all 100 V's as predictors.\nsummary(model1)$r.squared\nrmse <- function(x,y) sqrt(mean((x-y)^2)) #make a function to calculate the square root of the mean squared error\nrmse(model1$fit,meatspec$fat[1:172]) # Check the square root of the MSE for the training data. Differs from the regular MSE because the df for the rmse is n instead of df.residual\nrmse(predict(model1,meatspec[173:215,]),meatspec$fat[173:215]) # Calculate the sqrt of the MSPR using the data held out and the prediction based on the model derived with the training data. Note the large difference between training and validation sets.\nmodel2 <- step(model1, trace=0) # Perform automated stepwise regression using the AIC. trace=0 prevents verbose output.\nrmse(model2$fit,meatspec$fat[1:172]) # Check rmse for selected model.\nrmse(predict(model2,meatspec[173:215,]),meatspec$fat[173:215]) # Calculate rmse for selected model with validation data held out.\nlibrary(mva) # No longer needed. prcomp is part of stats.\nmeatpca <- prcomp(meatspec[1:172,-101]) # Do PCA on spectra of meat samples. Note that fat is left out. Based on covariance matrix.\nround(meatpca$sdev,3) # sqrt of eigenvalues. Note how quickly they decline.\nmeatpca2<- prcomp(meatspec[1:172,-101], scale.=T) # PCA based on correlation matrix.\nsum(meatpca$sdev^2) # Since they were not based on correlation they the sum is not = nvars.\nsum(meatpca2$sdev^2)\nmatplot(1:100,meatpca$rot[,1:3],type=\"l\",xlab=\"Light frequency\",ylab=\"\") # Plot the first 3 eigenvectors from the matrix of eigenvectors meatpca$rotation\nmodel3 <- lm(fat ~ meatpca$x[,1:4]  , meatspec[1:172,]) # PCR on the first 4 PC's unscaled\nmodel4 <- lm(fat ~ meatpca2$x[,1:4]  , meatspec[1:172,]) # PCR on the first 4 PC's scaled\nrmse(model3$fit,meatspec$fat[1:172]) # Check sqrt MSE for model with 4 PC's unscaled\nrmse(model4$fit,meatspec$fat[1:172]) # Check sqrt MSE for model with 4 PC's scaled\nplot(model1$coef[-1],ylab=\"Coefficient\") # Coefficients of the 100 V's in model 1\nsvb <- meatpca$rot[,1:4] %*% model3$coef[-1] # Calculate coefficients of V's based on PCR\nplot(svb,ylab=\"Coefficient\") #Coefficients of the 100 V's in model 3 based on 4 PC's\nplot(meatpca$sdev[1:10],type=\"l\",ylab=\"SD of PC\",xlab=\"PC number\") # Scree plot\n\n# Selecting the best set of PC to obtain a model with the lowest MSPR.\n\nmm <- apply(meatspec[1:172,-101],2,mean) # Obtain a vector mm with the means for the 100 V's in the first 172 observations\ntx <- as.matrix(sweep(meatspec[173:215,-101],2,mm)) # Center the observations held out with the means for the training data set (for consistency with the estimated parameters)\nnx <- tx %*%  meatpca$rot[,1:4] # Obtain the PC scores for the observations held out\npv <- cbind(1,nx) %*% model3$coef # Make predictions for held-oud data based on model 3\nrmse(pv,meatspec$fat[173:215]) # Calculate the sqrt MSPR for model 3\nrmsmeat <- numeric(50) # Make a container vector for all the MSPR's for the 50 PC's\n\n# Calculate and save the sqrt MSPR for models using from 1 to 50 PC's (unscaled)\nfor(i in 1:50){\nnx <- tx %*%  meatpca$rot[,1:i]\nm <- lm(fat ~ meatpca$x[,1:i]  , meatspec[1:172,])\npv <- cbind(1,nx) %*% m$coef\nrmsmeat[i] <- rmse(pv,meatspec$fat[173:215])\n}\nplot(rmsmeat,ylab=\"sqrt(MSPR)\",xlab=\"No. of Components\")\nwhich.min(rmsmeat)\nmin(rmsmeat)\n\n\n# Calculate and save the sqrt MSPR for models using from 1 to 50 PC's (scaled)\nsdVs<-apply(meatspec[1:172,-101],2,sd) # Get standard deviations of columns\ntx2<-as.matrix(sweep(tx,2,sdVs,FUN=\"/\"))\nrmsmeat2 <- numeric(50) # Make a container vector for all the MSPR's for the 50 PC's based on the correlation (scaled)\nfor(i in 1:50){\nnx <- tx2 %*%  meatpca2$rot[,1:i]\nm <- lm(fat ~ meatpca2$x[,1:i]  , meatspec[1:172,])\npv <- cbind(1,nx) %*% m$coef\nrmsmeat2[i] <- rmse(pv,meatspec$fat[173:215])\n}\nplot(rmsmeat2,ylab=\"sqrt(MSPR)\",xlab=\"No. of Components\", ylim=c(1.7,3))\nwhich.min(rmsmeat2)\nmin(rmsmeat2)\n\nm21<-lm(fat~meatpca2$x[,1:21], meatspec[1:172,])\nnx <- tx2 %*%  meatpca2$rot[,1:21]\npv21<-cbind(1,nx) %*% m21$coef\n\n# Essentially the same, but instead of reserving the same data for validation, using k-fold cross-validation to find a good model for predicting the fat content.\nlibrary(pls)\npcrmod <- pcr(fat ~ ., data=meatspec[1:172,], validation=\"CV\",ncomp=50)\nvalidationplot(pcrmod)\nplsg <- plsr(fat ~ ., data=meatspec[1:172,], ncomp=50, validation=\"CV\")\ncoefplot(plsg,ncomp=4,xlab=\"Frequency\")\nvalidationplot(plsg)\nypred <- predict(plsg,ncomp=14)\nrmse(ypred,meatspec$fat[1:172])\nytpred <- predict(plsg,meatspec[173:215,],ncomp=14)\nrmse(ytpred,meatspec$fat[173:215])\n",
    "created" : 1353868116879.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3052466400",
    "id" : "FE3D4F2C",
    "lastKnownWriteTime" : 1352785069,
    "path" : "~/Documents/TeachServ/CLASSES/AGR206/PLS206F10/RstudioPLS206/meatspec.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}