{
    "contents" : "##------------------------------------------------------------##\n##        Script for Getting Started With R                   ##\n##                       John Fox                             ##\n##          The R Statistical Computing Environment           ##\n##             ICPSR Summer Program Berkeley                  ##\n##                         2012                               ##\n##------------------------------------------------------------##\n\n# Basics\n\n    # arithmetic, interacting with the interpreter\n\n        # basic arithmetic operations\n\n2 + 3 # addition\n2 - 3 # subtraction\n2*3   # multiplication\n2/3   # division\n2^3   # exponentiation\n\n        # precedence of operators\n        \n4^2 - 3*2\n1 - 6 + 4\n2^-3\n\n(4^2) - (3*2) # use parentheses to group, clarify\n4 + 3^2\n(4 + 3)^2\n\n-2--3\n-2 - -3 # use spaces to clarify\n\n\n    # functions, arguments to functions, obtaining help and information\n\nlog(100)\nlog(100, base=10)\nlog10(100) # equivalent\nlog(100, b=10)  # argument abbreviation\n\nhelp(log)\n?log  # equivalent\nargs(log)\n\nlog(100, 10)  # arguments by position\n\nexample(\"log\")\n\napropos(\"log\")\nhelp.search(\"log\")\n\nRSiteSearch(\"loglinear\", \"functions\")\n\n`+`(2, 3) # even operators are functions\n\n    # vectors\n\nc(1, 2, 3, 4)  # combine\n\n1:4     # integer-sequence operator\n4:1\n-1:2    # note precedence\n-(1:2)\nseq(1, 4)\nseq(2, 8, by=2) # specify interval\nseq(0, 1, by=0.1) # non-integer sequence\nseq(0, 1, length=11) # specify number of elements\n\n    # vectorized arithmetic\n    \nc(1, 2, 3, 4)/2\nc(1, 2, 3, 4)/c(4, 3, 2, 1)\nlog(c(0.1, 1, 10, 100), 10)\n\nc(1, 2, 3, 4) + c(4, 3) # no warning\nc(1, 2, 3, 4) + c(4, 3, 2) # produces warning\n\n    # variables\n\nx <- c(1, 2, 3, 4) # assignment\nx # print\n\nx/2\n(y <- sqrt(x)) # assign and print\n\n(x <- rnorm(100))\nhead(x) # first few\nsummary(x)  # a \"generic\" function\n\n    # character and logical data\n    \n(words <- c(\"To\", \"be\", \"or\", \"not\", \"to\", \"be\"))\npaste(words, collapse=\" \")\n\n(vals <- c(TRUE, TRUE, FALSE, TRUE))\n!vals  # not operator\n\nsum(vals) # coercion to numeric\nsum(!vals)\nc(\"A\", FALSE, 3.0) # coercion to character\n\n    # basic indexing\n    \nx[12]    # 12th element\nwords[2] # second element\nvals[3]     # third element\n\nx[6:15] # elements 6 through 15\nx[-(11:100)] # omit elements 11 through 100 (note parentheses)\n\n    #comparison and logical operators\n\n1 == 2   # note == to test equality\n1 != 2\n1 <= 2\n1 < 1:3  # vectorized\n3:1 > 1:3\n3:1 >= 1:3\nTRUE & c(TRUE, FALSE)  # and\nc(TRUE, FALSE, FALSE) | c(TRUE, TRUE, FALSE)  # or\n\n    # unvectorized logical operators && and ||\n\nz <- \"a\"\nis.numeric(z) && (z <- z + 1)  # works b/c of lazy evaluation\nis.numeric(z) & (z <- z + 1)   # fails\n\n! c(T, F)   # abbreviations of TRUE and FALSE, best avoided!\nT <- FALSE  # perverse!\nT\nremove(T)\nTRUE <- FALSE  # fails\n\n(z <- x[1:10])\nz < -0.5\nz > 0.5\nz < -0.5 | z > 0.5  #  < and > of higher precedence than |\nabs(z) > 0.5  # absolute value\nz[abs(z) > 0.5] # indexing by a logical vector\n\n\n    # user-defined functions\n\nmean(x)\nsum(x)/length(x)\n\nmyMean <- function(x) sum(x)/length(x)\nmyMean # can be printed like any object\n\nmyMean(x)\ny # from sqrt(c(1, 2, 3, 4))\nmyMean(y)\nmyMean(1:100)\nhead(x) # global x undisturbed\n\nmyVar <- function(x) sum((x - myMean(x))^2)/(length(x) - 1)\nmyVar(1:100)\nvar(1:100) # check\n\n    # cleaning up\n\nobjects()\nremove(x, y, z, vals, words)\nobjects()\n\n    # using traceback()\n\nletters\nmyVar(letters)\n\ntraceback()\n\n\n# Duncan example (as time permits)\n    \n\n    # creating a data frame from data stored in a file\n\nDuncan <- read.table(file.choose(), header=TRUE)\nDuncan\nhead(Duncan)\nsummary(Duncan)  # generic summary function\n\n    # attaching a data frame (best avoided)\n\nprestige # error!\n\nattach(Duncan)\nprestige\n\n        # the search path\n\nsearch()\n\n    # distributions and bivariate relationships\n\nhist(prestige)\n\npairs(cbind(prestige, income, education))\n\npairs(cbind(prestige, income, education), \n    panel=function(x, y){\n        points(x, y)\n        abline(lm(y ~ x), lty=\"dashed\")\n        lines(lowess(x, y))\n        },\n    diag.panel=function(x){\n        par(new=TRUE)\n        hist(x, main=\"\", axes=FALSE)\n        }\n    )\n\nscatmat <- function(...) { # user-defined function\n    pairs(cbind(...),\n        panel=function(x, y){\n            points(x, y)\n            abline(lm(y ~ x), lty=2)\n            lines(lowess(x, y))\n        },\n        diag.panel=function(x){\n            par(new=TRUE)\n            hist(x, main=\"\", axes=FALSE)\n        }\n    )\n}\n\nscatmat(prestige, income, education)\n\nplot(income, education)\nidentify(income, education, row.names(Duncan)) # must exit from identify mode!\nrow.names(Duncan)[c(6, 16, 27)]\n\n    # fitting a regression\n\n(duncan.model <- lm(prestige ~ income + education))\nsummary(duncan.model)  # again, summary generic\n\n        # regression diagnostics\n\nlibrary(car)\nsearch()\n\nhist(rstudent(duncan.model))\nqqPlot(duncan.model, labels=row.names(Duncan), id.n=2)\n\nplot(hatvalues(duncan.model))\nabline(h = 2*3/45) # twice the average hat-value\nidentify(hatvalues(duncan.model), labels=row.names(Duncan)) # remember to exit!\n\nplot(cooks.distance(duncan.model))\nabline(h = 4/(45 - 3)) # rough cutoff for Cook's D\nidentify(cooks.distance(duncan.model), labels=row.names(Duncan))\n\navPlots(duncan.model, labels=rownames(Duncan), \n        id.method=\"identify\", id.cex=0.75)\n\ncrPlots(duncan.model, span=0.7)\n\nspreadLevelPlot(duncan.model)\n\nncvTest(duncan.model)\nncvTest(duncan.model, var.formula= ~ income + education)\n\n        # refitting the model\n\n(remove <- whichNames(c(\"minister\", \"conductor\"), Duncan))\nsummary(update(duncan.model, subset=-remove))\n\ndetach(\"Duncan\")\n\n# Generic functions, methods, and the class-based S3 object system\n    \nsummary(Duncan$type)  # a factor\nsummary(Duncan$prestige)  # a numeric variable\nsummary(Duncan)  # a data frame\nsummary(duncan.model)  # a linear model \n\nclass(Duncan$type)\nclass(Duncan$prestige)\nclass(Duncan)\nclass(duncan.model)\n\nsummary # the generic summary function\nargs(summary.lm) # the lm summary method\nsummary(duncan.model)\nsummary.lm(duncan.model) # equivalent, but bad form\n\nmethods(coef)  # methods of the coef generic\ncoef(duncan.model) # invokes default method\n\n?Mroz\n(mod.mroz <- glm(lfp ~ ., family=binomial, data=Mroz)) # logistic regression\nclass(mod.mroz)\nargs(summary.glm)\nsummary(mod.mroz)\nsummary.glm(mod.mroz)\n\nmethods(variable.names)\nvariable.names(duncan.model)\nvariable.names(mod.mroz)  # invokes the lm method\n",
    "created" : 1349151929838.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1335497814",
    "id" : "7112D880",
    "lastKnownWriteTime" : 1343749973,
    "path" : "~/Documents/TeachServ/CLASSES/AGR206/R WorkshopBerkeley/getting-started.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}